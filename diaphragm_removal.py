# -*- coding: utf-8 -*-
"""diaphragm_removal.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GXzaWnrBNLDLCTx_7jPqP1MaKv2aUeoW
"""

import numpy as np
import cv2
from google.colab.patches import cv2_imshow


img = cv2.imread('atelectasis.jpg', 1)
img_copy = np.copy(img)
img_copy_master = np.copy(img)

max_pixel = 0
min_pixel = 300

#cv2_imshow(img)


for row in img:
  for item in row:
    pixel_value = item[0]
    if pixel_value > max_pixel:
      max_pixel = pixel_value
    
    if pixel_value < min_pixel:
      min_pixel = pixel_value

T = min_pixel + (0.9 * (max_pixel - min_pixel))

#print(T)
for row in range(len(img)):
  for item in range(len(img[row])):
      pixel_value = img[row][item][0]
      if pixel_value > T:
        img[row][item] = [255, 255, 255]
      else:
        img[row][item] = [0, 0, 0]

#Inverted Binary Image
#cv2_imshow(img)

# Convert to grayscale for connectedComponentsWithStats to work
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
#cv2_imshow(gray)

components = cv2.connectedComponentsWithStats(gray)
(numLabels, labels, stats, centroids) = components

# Find max area and start at 1 because 0 is background
areas = []
for i in range(1, numLabels):
  areas.append(stats[i, cv2.CC_STAT_AREA])

mask = np.zeros(gray.shape, dtype="uint8")

# Keep largest area and remove others
max_area = max(areas)
for i in range(numLabels):
  area = stats[i, cv2.CC_STAT_AREA]
  if area == max_area:
    componentMask = (labels == i).astype("uint8") * 255
    mask = cv2.bitwise_or(mask, componentMask)
  
#cv2_imshow(mask)

# Fill holes with closing
kernel = np.ones((20,20),np.uint8)
closing = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)
#cv2_imshow(closing)

# Smooth boundary
kernel = np.ones((20,20),np.uint8)
opening = cv2.morphologyEx(closing, cv2.MORPH_OPEN, kernel)
#cv2_imshow(opening)

# Map removed diaphragm onto original image
for row in range(len(opening)):
  for item in range(len(opening[row])):
      pixel_value = opening[row][item]
      if pixel_value == 255:
        img_copy[row][item] = [0,0,0]

#cv2_imshow(img_copy)
# cv2_imshow(img_copy_master)

cv2.imwrite('atelectasis_no_diaphragm.jpg', img_copy)

gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
#cv2_imshow(gray)

components = cv2.connectedComponentsWithStats(gray)
(numLabels, labels, stats, centroids) = components
# print(stats[1, cv2.CC_STAT_LEFT])
# print(stats[1, cv2.CC_STAT_TOP])

# print(numLabels)
areas = []
for i in range(1, numLabels):
  areas.append(stats[i, cv2.CC_STAT_AREA])

mask = np.zeros(gray.shape, dtype="uint8")

max_area = max(areas)
for i in range(numLabels):
  area = stats[i, cv2.CC_STAT_AREA]
  if area == max_area:
    componentMask = (labels == i).astype("uint8") * 255
    mask = cv2.bitwise_or(mask, componentMask)
  
#cv2_imshow(mask)
kernel = np.ones((20,20),np.uint8)
closing = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)
cv2_imshow(closing)

kernel = np.ones((20,20),np.uint8)

opening = cv2.morphologyEx(closing, cv2.MORPH_OPEN, kernel)
cv2_imshow(opening)


  
# for i in range(numLabels):
#   x = stats[i, cv2.CC_STAT_LEFT]
#   y = stats[i, cv2.CC_STAT_TOP]
#   w = stats[i, cv2.CC_STAT_WIDTH]
#   h = stats[i, cv2.CC_STAT_HEIGHT]
#   area = stats[i, cv2.CC_STAT_AREA]
#   (cX, cY) = centroids[i]

  # output = gray.copy()
  # cv2.rectangle(output, (x, y), (x + w, y + h), (0, 255, 0), 3)
  # cv2.circle(output, (int(cX), int(cY)), 4, (0, 0, 255), -1)
  # cv2_imshow(output)
  # cv2.waitKey(0)